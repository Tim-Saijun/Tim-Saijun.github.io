{"title":"stderr和stdout：理解日志与输出","uid":"d8719e661cefd842e9603629d87bd5b8","slug":"standard-output","date":"2024-02-17T12:42:32.000Z","updated":"2024-02-22T03:52:13.945Z","comments":true,"path":"api/articles/standard-output.json","keywords":"计算机技术,大数据,人工智能","cover":"https://images.unsplash.com/photo-1609666973548-54217494b70d?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wzNjAwOTd8MHwxfHNlYXJjaHwxNnx8b3V0cHV0fGVufDB8fHx8MTcwODE3Mzc5NHww&ixlib=rb-4.0.3&q=80&w=800","content":"<p>标准输出（<code>stdout</code>）与标准错误（<code>stderr</code>）这两个概念虽然简单，但在日志记录、错误处理和数据流管理中扮演着核心角色。本文将探讨<code>stdout</code>和<code>stderr</code>的区别和应用，尤其是在Python环境中如何有效地使用它们。</p>\n<h2 id=\"标准输出（stdout）与标准错误（stderr）\"><a href=\"#标准输出（stdout）与标准错误（stderr）\" class=\"headerlink\" title=\"标准输出（stdout）与标准错误（stderr）\"></a>标准输出（<code>stdout</code>）与标准错误（<code>stderr</code>）</h2><p>在大多数操作系统中，标准输出和标准错误是进程的两个主要输出流。它们提供了一种机制，使得进程可以将信息和错误消息发送到终端或文件。虽然这两个流在物理上可能相同（例如，都显示在同一终端界面上），但它们在逻辑上用于不同的目的：</p>\n<ul>\n<li><strong>标准输出（<code>stdout</code>）</strong>：通常用于输出程序的执行结果或正常的运行信息。</li>\n<li><strong>标准错误（<code>stderr</code>）</strong>：专门用于输出错误消息或警告，即使在标准输出被重定向时，这些信息通常也需要被看到或记录。</li>\n</ul>\n<h2 id=\"Python中的print和logging\"><a href=\"#Python中的print和logging\" class=\"headerlink\" title=\"Python中的print和logging\"></a>Python中的<code>print</code>和<code>logging</code></h2><p>在Python中，<code>print</code>函数默认将信息发送到<code>stdout</code>，而<code>logging</code>模块则默认将日志消息发送到<code>stderr</code>。这样做的目的是区分正常的程序输出和日志（包括错误和调试信息）输出，使得开发者可以更容易地管理和过滤输出信息。</p>\n<h3 id=\"使用print\"><a href=\"#使用print\" class=\"headerlink\" title=\"使用print\"></a>使用<code>print</code></h3><p><code>print</code>是Python中最基本的输出函数，用于将信息输出到标准输出流。它简单易用，适合于快速的调试或向用户显示信息。例如：</p>\n<div class=\"language-python\"><button title=\"Copy code\" class=\"copy\" onclick=\"copyCode(this)\"></button><span class=\"lang\">python</span><pre class=\"shiki dracula\" style=\"background-color: #282A36\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #8BE9FD\">print</span><span style=\"color: #F8F8F2\">(</span><span style=\"color: #E9F284\">&quot;</span><span style=\"color: #F1FA8C\">Hello, world!</span><span style=\"color: #E9F284\">&quot;</span><span style=\"color: #F8F8F2\">)</span></span></code></pre></div><h3 id=\"使用logging\"><a href=\"#使用logging\" class=\"headerlink\" title=\"使用logging\"></a>使用<code>logging</code></h3><p><code>logging</code>模块提供了一个灵活的框架，用于在应用程序中添加日志消息。与<code>print</code>不同，<code>logging</code>支持不同的日志级别（DEBUG, INFO, WARNING, ERROR, CRITICAL），允许开发者根据需要调整日志的详细程度和输出位置。例如：</p>\n<div class=\"language-python\"><button title=\"Copy code\" class=\"copy\" onclick=\"copyCode(this)\"></button><span class=\"lang\">python</span><pre class=\"shiki dracula\" style=\"background-color: #282A36\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #FF79C6\">import</span><span style=\"color: #F8F8F2\"> logging</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #F8F8F2\">logging.error(</span><span style=\"color: #E9F284\">&#39;</span><span style=\"color: #F1FA8C\">This is an error message</span><span style=\"color: #E9F284\">&#39;</span><span style=\"color: #F8F8F2\">)</span></span>\n<span class=\"line\"></span></code></pre></div><h2 id=\"tqdm与stderr\"><a href=\"#tqdm与stderr\" class=\"headerlink\" title=\"tqdm与stderr\"></a>tqdm与<code>stderr</code></h2><p>在复杂的或长时间运行的程序中，使用进度条是向用户展示进程进度的一种有效方式。Python的<code>tqdm</code>库是一个广泛使用的工具，用于在命令行中添加进度条。<code>tqdm</code>默认将进度信息输出到<code>stderr</code>，以免干扰到正常的程序输出（<code>stdout</code>）。</p>\n<h3 id=\"分流stdout和stderr\"><a href=\"#分流stdout和stderr\" class=\"headerlink\" title=\"分流stdout和stderr\"></a>分流<code>stdout</code>和<code>stderr</code></h3><p>在某些情况下，将正常输出和错误或日志消息分开，例如，将它们重定向到不同的文件或终端。在命令行中，可以使用重定向操作符<code>&gt;</code>和<code>2&gt;</code>来实现。在Python代码中，可以通过配置<code>logging</code>模块或使用特定的文件对象来实现更细粒度的控制。</p>\n<div class=\"language-bash\"><button title=\"Copy code\" class=\"copy\" onclick=\"copyCode(this)\"></button><span class=\"lang\">bash</span><pre class=\"shiki dracula\" style=\"background-color: #282A36\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #50FA7B\">python</span><span style=\"color: #F8F8F2\"> </span><span style=\"color: #F1FA8C\">script.py</span><span style=\"color: #F8F8F2\"> </span><span style=\"color: #FF79C6\">&gt;</span><span style=\"color: #F8F8F2\"> </span><span style=\"color: #F1FA8C\">output.log</span><span style=\"color: #F8F8F2\"> </span><span style=\"color: #FF79C6\">2&gt;</span><span style=\"color: #F8F8F2\"> </span><span style=\"color: #F1FA8C\">error.log</span></span>\n<span class=\"line\"></span></code></pre></div><p>通过命令行重定向、Python的<code>print</code>函数甚至<code>logging</code>模块，都可以灵活地控制和分流这两种类型的输出，使得错误处理、日志记录和用户交互更加清晰和有序。</p>\n<h2 id=\"使用nohup管理stdout和stderr\"><a href=\"#使用nohup管理stdout和stderr\" class=\"headerlink\" title=\"使用nohup管理stdout和stderr\"></a>使用<code>nohup</code>管理<code>stdout</code>和<code>stderr</code></h2><p>在部署长时间运行的后台进程时，<code>nohup</code>命令成为了一个重要的工具。<code>nohup</code>，或“no hang up”，允许命令在用户注销后继续运行，这对于远程启动任务尤其有用。<code>nohup</code>的一个关键特性是它的能力来管理<code>stdout</code>和<code>stderr</code>。</p>\n<p>默认情况下，使用<code>nohup</code>运行命令会将<code>stdout</code>和<code>stderr</code>合并重定向到<code>nohup.out</code>文件，除非另外指定。这意味着无论是正常的输出还是错误消息，都会被捕获到同一个文件中，方便日后审查。但在某些情况下，将这两种输出分开可能更有用。</p>\n<h3 id=\"分开stdout和stderr的nohup使用\"><a href=\"#分开stdout和stderr的nohup使用\" class=\"headerlink\" title=\"分开stdout和stderr的nohup使用\"></a>分开<code>stdout</code>和<code>stderr</code>的<code>nohup</code>使用</h3><p>要在使用<code>nohup</code>时将<code>stdout</code>和<code>stderr</code>输出到不同的文件，可以结合使用重定向操作符。例如：</p>\n<div class=\"language-bash\"><button title=\"Copy code\" class=\"copy\" onclick=\"copyCode(this)\"></button><span class=\"lang\">bash</span><pre class=\"shiki dracula\" style=\"background-color: #282A36\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #50FA7B\">nohup</span><span style=\"color: #F8F8F2\"> </span><span style=\"color: #F1FA8C\">python</span><span style=\"color: #F8F8F2\"> </span><span style=\"color: #F1FA8C\">script.py</span><span style=\"color: #F8F8F2\"> </span><span style=\"color: #FF79C6\">&gt;</span><span style=\"color: #F8F8F2\"> </span><span style=\"color: #F1FA8C\">output.log</span><span style=\"color: #F8F8F2\"> </span><span style=\"color: #FF79C6\">2&gt;</span><span style=\"color: #F8F8F2\"> </span><span style=\"color: #F1FA8C\">error.log</span><span style=\"color: #F8F8F2\"> &amp;</span></span></code></pre></div><p>这条命令将<code>stdout</code>重定向到<code>output.log</code>，<code>stderr</code>重定向到<code>error.log</code>，并通过<code>&amp;</code>在后台运行。这样，即使关闭了终端或者SSH会话，程序也会继续运行，并且其输出会被妥善记录。</p>\n<h2 id=\"在Python中的缓冲行为\"><a href=\"#在Python中的缓冲行为\" class=\"headerlink\" title=\"在Python中的缓冲行为\"></a>在Python中的缓冲行为</h2><p><code>stdout</code>和<code>stderr</code>在缓冲数据时表现不同。默认情况下，<code>stdout</code>是行缓冲的，当连接到终端时，它会缓存数据直到收到换行符或缓冲区满；在非交互模式下，<code>stdout</code> 是块缓冲的（像文件一样）。 而<code>stderr</code>总是行缓冲的（python 3.9版本之前，非交互模式下是块缓冲）。以下内容来自官方文档<a href=\"https://docs.python.org/3.12/library/sys.html#sys.stdout\">sys — 系统相关的形参和函数 — Python 3.12.2 文档</a></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>When interactive, the <code>stdout</code> stream is line-buffered. Otherwise, it is block-buffered like regular text files. The <code>stderr</code> stream is line-buffered in both cases. You can make both streams unbuffered by passing the <code>[u](&lt;https://docs.python.org/3.12/using/cmdline.html#cmdoption-u&gt;)</code> command-line option or setting the <code>[PYTHONUNBUFFERED](&lt;https://docs.python.org/3.12/using/cmdline.html#envvar-PYTHONUNBUFFERED&gt;)</code> environment variable.</p>\n<p><em>Changed in version 3.9:</em> Non-interactive <code>stderr</code> is now line-buffered instead of fully buffered.</p></blockquote>\n<p>缓冲粒度越小，输出就越及时，但相应的IO代价就更大。Python 3.8及之前，将<code>stdout</code> 和<code>stderr</code> 做了相同粒度的缓冲，实在是不太合理；在3.9版本后，<code>stderr</code> 有了更小的缓冲粒度，意味着每个写入操作的输出会比<code>stdout</code> 更及时。这种差异使得<code>stderr</code>适合于错误和日志信息，确保即使在程序崩溃或异常退出时，这些信息也能比标准输出有更高的优先级。</p>\n<p>在C++中，标准错误是无缓冲的（见后文），更为激进，但我个人认为这种会更合理一些。</p>\n<p>但好在，Python中可以通过<code>python -u</code>或设置环境变量<code>PYTHONUNBUFFERED</code>来禁用这种缓冲行为，或是直接操作<code>sys.stdout.flush()</code>来控制输出时机。</p>\n<h2 id=\"在Python并发环境中的表现\"><a href=\"#在Python并发环境中的表现\" class=\"headerlink\" title=\"在Python并发环境中的表现\"></a>在Python并发环境中的表现</h2><p>在多线程或多进程环境中使用<code>stdout</code>和<code>stderr</code>时，输出可能会交错或混乱，因为来自不同线程或进程的输出可能会在写入终端或文件时相互干扰。解决这一问题的一种方法是为每个线程或进程创建独立的输出文件，或使用线程锁（thread locks）或进程同步机制（如<code>multiprocessing.Lock</code>）来同步对<code>stdout</code>或<code>stderr</code>的访问。</p>\n<h2 id=\"Python控制stdout和stderr\"><a href=\"#Python控制stdout和stderr\" class=\"headerlink\" title=\"Python控制stdout和stderr\"></a>Python控制<code>stdout</code>和<code>stderr</code></h2><p>在复杂的应用中，你可能需要更灵活地控制输出流的目的地。Python提供了多种方式来实现这一点：</p>\n<ul>\n<li>**重定向<code>stdout</code>和<code>stderr</code>**：可以通过改变<code>sys.stdout</code>和<code>sys.stderr</code>的值来重定向Python程序的标准输出和错误输出。这对于捕获和分析输出，或将输出重定向到图形界面等非标准输出设备特别有用。</li>\n<li><strong>使用<code>subprocess</code>模块</strong>：当运行外部命令或脚本时，<code>subprocess</code>模块允许你控制命令的<code>stdout</code>和<code>stderr</code>流，包括将它们重定向到Python程序内部的变量，或将它们分开或合并。</li>\n<li><strong>日志模块的高级应用</strong>：Python的<code>logging</code>模块支持将日志输出到多个目的地，包括文件、标准输出、网络等。通过配置不同的日志处理器（handlers），你可以实现复杂的日志管理方案，如基于日志级别或消息内容将日志分流到不同的输出中。</li>\n</ul>\n<h3 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a>建议</h3><ul>\n<li><strong>谨慎管理输出</strong>：在设计软件时，明确区分用于用户交互的输出（<code>stdout</code>）和用于错误报告或日志记录的输出（<code>stderr</code>）。这有助于提高程序的可用性和维护性。</li>\n<li><strong>优化性能</strong>：考虑输出操作的性能影响，特别是在高频率日志或数据输出的场景下。合理使用缓冲和批量处理可以减少对性能的影响。</li>\n<li><strong>安全性考虑</strong>：在输出敏感信息前进行适当的过滤和脱敏，避免通过日志泄露敏感数据。</li>\n</ul>\n<p>通过深入理解和灵活应用<code>stdout</code>和<code>stderr</code>，可以构建出更健壮、更易于管理的Python应用程序，有效地处理日志和输出，提升用户体验和应用稳定性。</p>\n<h2 id=\"在C-中的缓冲行为\"><a href=\"#在C-中的缓冲行为\" class=\"headerlink\" title=\"在C++中的缓冲行为\"></a>在C++中的缓冲行为</h2><p>在C++中，<code>stdout</code>（通常对应于<code>std::cout</code>）和<code>stderr</code>（对应于<code>std::cerr</code>）有不同的缓冲策略：</p>\n<ul>\n<li><strong><code>std::cout</code></strong> 默认是行缓冲的，这意味着当它连接到一个终端时，输出会在每次换行时刷新，或者缓冲区满时刷新。</li>\n<li><strong><code>std::cerr</code></strong> 默认是无缓冲的，因此每次写入<code>std::cerr</code>的数据都会立即输出，这对于报告错误信息非常有用，因为它减少了程序崩溃导致错误信息未被输出的风险。</li>\n</ul>\n<h2 id=\"重定向stdout和stderr\"><a href=\"#重定向stdout和stderr\" class=\"headerlink\" title=\"重定向stdout和stderr\"></a>重定向<code>stdout</code>和<code>stderr</code></h2><p>在C++程序中，可以通过多种方式重定向<code>stdout</code>和<code>stderr</code>。一种常见的方法是使用<code>freopen</code>函数在程序运行时重定向标准输出或错误输出到文件：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\" onclick=\"copyCode(this)\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dracula\" style=\"background-color: #282A36\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #50FA7B\">freopen</span><span style=\"color: #F8F8F2\">(</span><span style=\"color: #E9F284\">&quot;</span><span style=\"color: #F1FA8C\">output.txt</span><span style=\"color: #E9F284\">&quot;</span><span style=\"color: #F8F8F2\">, </span><span style=\"color: #E9F284\">&quot;</span><span style=\"color: #F1FA8C\">w</span><span style=\"color: #E9F284\">&quot;</span><span style=\"color: #F8F8F2\">, stdout);</span></span>\n<span class=\"line\"><span style=\"color: #50FA7B\">freopen</span><span style=\"color: #F8F8F2\">(</span><span style=\"color: #E9F284\">&quot;</span><span style=\"color: #F1FA8C\">error.log</span><span style=\"color: #E9F284\">&quot;</span><span style=\"color: #F8F8F2\">, </span><span style=\"color: #E9F284\">&quot;</span><span style=\"color: #F1FA8C\">w</span><span style=\"color: #E9F284\">&quot;</span><span style=\"color: #F8F8F2\">, stderr);</span></span></code></pre></div><p>这种方法可以用于将输出重定向到文件，方便日后分析和调试。</p>\n<h2 id=\"C-多线程环境中的使用\"><a href=\"#C-多线程环境中的使用\" class=\"headerlink\" title=\"C++多线程环境中的使用\"></a>C++多线程环境中的使用</h2><p>在多线程的C++程序中使用<code>std::cout</code>和<code>std::cerr</code>时，可能会遇到竞争条件，导致输出混乱。为了避免这种情况，推荐使用互斥锁（如<code>std::mutex</code>）来同步对这些流的访问：</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\" onclick=\"copyCode(this)\"></button><span class=\"lang\">cpp</span><pre class=\"shiki dracula\" style=\"background-color: #282A36\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #FF79C6\">#include</span><span style=\"color: #F8F8F2\"> </span><span style=\"color: #E9F284\">&lt;</span><span style=\"color: #F1FA8C\">iostream</span><span style=\"color: #E9F284\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #FF79C6\">#include</span><span style=\"color: #F8F8F2\"> </span><span style=\"color: #E9F284\">&lt;</span><span style=\"color: #F1FA8C\">mutex</span><span style=\"color: #E9F284\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #FF79C6\">#include</span><span style=\"color: #F8F8F2\"> </span><span style=\"color: #E9F284\">&lt;</span><span style=\"color: #F1FA8C\">thread</span><span style=\"color: #E9F284\">&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #F8F8F2\">std</span><span style=\"color: #FF79C6\">::</span><span style=\"color: #F8F8F2\">mutex cout_mutex;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #FF79C6\">void</span><span style=\"color: #F8F8F2\"> </span><span style=\"color: #50FA7B\">thread_function</span><span style=\"color: #F8F8F2\">(</span><span style=\"color: #FF79C6\">int</span><span style=\"color: #F8F8F2\"> </span><span style=\"color: #FFB86C; font-style: italic\">id</span><span style=\"color: #F8F8F2\">) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #F8F8F2\">    std</span><span style=\"color: #FF79C6\">::</span><span style=\"color: #F8F8F2\">lock_guard</span><span style=\"color: #FF79C6\">&lt;</span><span style=\"color: #F8F8F2\">std</span><span style=\"color: #FF79C6\">::</span><span style=\"color: #F8F8F2\">mutex</span><span style=\"color: #FF79C6\">&gt;</span><span style=\"color: #F8F8F2\"> </span><span style=\"color: #50FA7B\">lock</span><span style=\"color: #F8F8F2\">(cout_mutex);</span></span>\n<span class=\"line\"><span style=\"color: #F8F8F2\">    std</span><span style=\"color: #FF79C6\">::</span><span style=\"color: #F8F8F2\">cout </span><span style=\"color: #FF79C6\">&lt;&lt;</span><span style=\"color: #F8F8F2\"> </span><span style=\"color: #E9F284\">&quot;</span><span style=\"color: #F1FA8C\">Thread </span><span style=\"color: #E9F284\">&quot;</span><span style=\"color: #F8F8F2\"> </span><span style=\"color: #FF79C6\">&lt;&lt;</span><span style=\"color: #F8F8F2\"> id </span><span style=\"color: #FF79C6\">&lt;&lt;</span><span style=\"color: #F8F8F2\"> </span><span style=\"color: #E9F284\">&quot;</span><span style=\"color: #F1FA8C\"> is running</span><span style=\"color: #FF79C6\">\\\\\\\\</span><span style=\"color: #F1FA8C\">n</span><span style=\"color: #E9F284\">&quot;</span><span style=\"color: #F8F8F2\">;</span></span>\n<span class=\"line\"><span style=\"color: #F8F8F2\">&#125;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #FF79C6\">int</span><span style=\"color: #F8F8F2\"> </span><span style=\"color: #50FA7B\">main</span><span style=\"color: #F8F8F2\">() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #F8F8F2\">    std</span><span style=\"color: #FF79C6\">::</span><span style=\"color: #F8F8F2\">thread </span><span style=\"color: #50FA7B\">t1</span><span style=\"color: #F8F8F2\">(thread_function, </span><span style=\"color: #BD93F9\">1</span><span style=\"color: #F8F8F2\">);</span></span>\n<span class=\"line\"><span style=\"color: #F8F8F2\">    std</span><span style=\"color: #FF79C6\">::</span><span style=\"color: #F8F8F2\">thread </span><span style=\"color: #50FA7B\">t2</span><span style=\"color: #F8F8F2\">(thread_function, </span><span style=\"color: #BD93F9\">2</span><span style=\"color: #F8F8F2\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #F8F8F2\">    t1.</span><span style=\"color: #50FA7B\">join</span><span style=\"color: #F8F8F2\">();</span></span>\n<span class=\"line\"><span style=\"color: #F8F8F2\">    t2.</span><span style=\"color: #50FA7B\">join</span><span style=\"color: #F8F8F2\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #F8F8F2\">    </span><span style=\"color: #FF79C6\">return</span><span style=\"color: #F8F8F2\"> </span><span style=\"color: #BD93F9\">0</span><span style=\"color: #F8F8F2\">;</span></span>\n<span class=\"line\"><span style=\"color: #F8F8F2\">&#125;</span></span></code></pre></div><h2 id=\"C-控制输出\"><a href=\"#C-控制输出\" class=\"headerlink\" title=\"C++控制输出\"></a>C++控制输出</h2><p>C++标准库提供了<code>std::streambuf</code>，可以用来实现对<code>std::cout</code>和<code>std::cerr</code>更细粒度的控制，包括重定向和自定义缓冲行为。通过继承<code>std::streambuf</code>并重写相应的成员函数，你可以创建自定义的缓冲策略，或将输出重定向到GUI组件、网络连接等。</p>\n<h3 id=\"建议-1\"><a href=\"#建议-1\" class=\"headerlink\" title=\"建议\"></a>建议</h3><ul>\n<li><strong>合理使用缓冲</strong>：根据应用场景选择合适的缓冲策略。对于需要立即反馈的错误信息，使用<code>std::cerr</code>或手动刷新<code>std::cout</code>。</li>\n<li><strong>避免在多线程中直接使用标准输出</strong>：使用互斥锁或其他同步机制来保证输出的一致性和顺序。</li>\n<li>**使用重定向和自定义<code>streambuf</code>**：为了更灵活地处理输出，考虑使用重定向或自定义<code>streambuf</code>来实现特殊的输出需求，如日志记录、网络传输等。</li>\n</ul>\n<p>通过掌握这些进阶技术，可以在保证C++程序健壮性和灵活性的同时，有效地管理和控制程序的输出。</p>\n","feature":true,"text":"标准输出（stdout）与标准错误（stderr）这两个概念虽然简单，但在日志记录、错误处理和数据流管理中扮演着核心角色。本文将探讨stdout和stderr的...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"算法编程","slug":"算法编程","count":2,"path":"api/categories/算法编程.json"}],"tags":[{"name":"标准输出","slug":"标准输出","count":1,"path":"api/tags/标准输出.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%EF%BC%88stdout%EF%BC%89%E4%B8%8E%E6%A0%87%E5%87%86%E9%94%99%E8%AF%AF%EF%BC%88stderr%EF%BC%89\"><span class=\"toc-text\">标准输出（stdout）与标准错误（stderr）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Python%E4%B8%AD%E7%9A%84print%E5%92%8Clogging\"><span class=\"toc-text\">Python中的print和logging</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8print\"><span class=\"toc-text\">使用print</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8logging\"><span class=\"toc-text\">使用logging</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#tqdm%E4%B8%8Estderr\"><span class=\"toc-text\">tqdm与stderr</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%B5%81stdout%E5%92%8Cstderr\"><span class=\"toc-text\">分流stdout和stderr</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8nohup%E7%AE%A1%E7%90%86stdout%E5%92%8Cstderr\"><span class=\"toc-text\">使用nohup管理stdout和stderr</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E5%BC%80stdout%E5%92%8Cstderr%E7%9A%84nohup%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">分开stdout和stderr的nohup使用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%A8Python%E4%B8%AD%E7%9A%84%E7%BC%93%E5%86%B2%E8%A1%8C%E4%B8%BA\"><span class=\"toc-text\">在Python中的缓冲行为</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%A8Python%E5%B9%B6%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%8E%B0\"><span class=\"toc-text\">在Python并发环境中的表现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Python%E6%8E%A7%E5%88%B6stdout%E5%92%8Cstderr\"><span class=\"toc-text\">Python控制stdout和stderr</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BB%BA%E8%AE%AE\"><span class=\"toc-text\">建议</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9C%A8C-%E4%B8%AD%E7%9A%84%E7%BC%93%E5%86%B2%E8%A1%8C%E4%B8%BA\"><span class=\"toc-text\">在C++中的缓冲行为</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%87%8D%E5%AE%9A%E5%90%91stdout%E5%92%8Cstderr\"><span class=\"toc-text\">重定向stdout和stderr</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">C++多线程环境中的使用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#C-%E6%8E%A7%E5%88%B6%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">C++控制输出</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BB%BA%E8%AE%AE-1\"><span class=\"toc-text\">建议</span></a></li></ol></li></ol>","author":{"name":"以太工坊","slug":"blog-author","avatar":"/img/logo.png","link":"/","description":"分享我的课程学习笔记、经验与有趣的小玩意.图片等资源无法加载时请使用代理","socials":{"github":"https://github.com/Tim-Saijun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"telegram":{"icon":"/img/telegram.svg","link":"https://t.me/tim_run"},"Email":{"icon":"/img/mail.svg","link":"mailto:b@zair.top"},"RSS":{"icon":"/img/rss.svg","link":"/atom.xml"}}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"网页长截图自动分割工具","uid":"7257ab73c9c7b2fb6eabab288ff4c4fc","slug":"Web-page-Screenshot-Segmentation","date":"2024-02-06T03:29:01.000Z","updated":"2024-02-22T03:52:13.945Z","comments":true,"path":"api/articles/Web-page-Screenshot-Segmentation.json","keywords":"计算机技术,大数据,人工智能","cover":"https://images.unsplash.com/photo-1601972602288-3be527b4f18a?q=80&w=2370&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&q=80&w=800","text":"背景当需要分享或分析网页内容时，长截图是一种非常实用的形式，它能够完整地展示页面。然而，处理这些长截图时，如何保持其信息的完整性和可读性，同时方便进行后续操作，...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"OpenCV","slug":"OpenCV","count":2,"path":"api/categories/OpenCV.json"}],"tags":[{"name":"代码工具","slug":"代码工具","count":2,"path":"api/tags/代码工具.json"},{"name":"OpenCV","slug":"OpenCV","count":1,"path":"api/tags/OpenCV.json"}],"author":{"name":"以太工坊","slug":"blog-author","avatar":"/img/logo.png","link":"/","description":"分享我的课程学习笔记、经验与有趣的小玩意.图片等资源无法加载时请使用代理","socials":{"github":"https://github.com/Tim-Saijun","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"telegram":{"icon":"/img/telegram.svg","link":"https://t.me/tim_run"},"Email":{"icon":"/img/mail.svg","link":"mailto:b@zair.top"},"RSS":{"icon":"/img/rss.svg","link":"/atom.xml"}}}},"feature":true}}